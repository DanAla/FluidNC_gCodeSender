cmake_minimum_required(VERSION 3.16)

# --- Start Versioning ---
find_package(Git REQUIRED)
set(VERSION_HEADER_PATH "${CMAKE_BINARY_DIR}/generated_version.h")

# Try to get the version from Git
execute_process(
    COMMAND ${GIT_EXECUTABLE} --git-dir=${CMAKE_SOURCE_DIR}/../.git --work-tree=${CMAKE_SOURCE_DIR}/.. describe --tags --abbrev=0
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}/..
    OUTPUT_VARIABLE GIT_LATEST_TAG
    OUTPUT_STRIP_TRAILING_WHITESPACE
    RESULT_VARIABLE GIT_RESULT
)

set(CONFIGURE_VERSION_HEADER TRUE)
set(PROJECT_VERSION_STRING "0.0.0") # Default version

if(NOT GIT_RESULT EQUAL 0)
    # Git command failed, try to use existing version file
    message(WARNING "Git tag lookup failed. Trying to use existing version file.")
    if(EXISTS ${VERSION_HEADER_PATH})
        message(STATUS "Using existing version header. Build will continue with last known version.")
        set(CONFIGURE_VERSION_HEADER FALSE)
        # Parse version from existing file for the project() command
        file(READ ${VERSION_HEADER_PATH} EXISTING_HEADER_CONTENT)
        string(REGEX MATCH "#define VERSION_STRING[ \t]+\"([^\"]+)\"" _match "${EXISTING_HEADER_CONTENT}")
        set(PROJECT_VERSION_STRING "${CMAKE_MATCH_1}")
        if(NOT PROJECT_VERSION_STRING)
             set(PROJECT_VERSION_STRING "0.0.0") # Safety fallback
        endif()
    else()
        # Git failed on a clean build, default to 0.0.0 and generate a header
        message(WARNING "No existing version header found. Defaulting to version 0.0.0")
        set(GIT_LATEST_TAG "v0.0.0")
    endif()
endif()

if(CONFIGURE_VERSION_HEADER)
    # This block runs if Git succeeded, or if it failed on a clean build
    if(GIT_LATEST_TAG MATCHES "^v?([0-9]+)\\.([0-9]+)\\.([0-9]+)")
        set(PROJECT_VERSION_MAJOR ${CMAKE_MATCH_1})
        set(PROJECT_VERSION_MINOR ${CMAKE_MATCH_2})
        set(PROJECT_VERSION_PATCH ${CMAKE_MATCH_3})
        set(PROJECT_VERSION_STRING "${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}")
    else()
        set(PROJECT_VERSION_MAJOR 0)
        set(PROJECT_VERSION_MINOR 0)
        set(PROJECT_VERSION_PATCH 0)
        set(PROJECT_VERSION_STRING "0.0.0")
        if(NOT GIT_LATEST_TAG)
            set(GIT_LATEST_TAG "v0.0.0")
        endif()
    endif()

    set(VERSION_HEADER_CONTENT "#pragma once\n// Auto-generated by CMake, do not edit.\n\n#define VERSION_MAJOR           ${PROJECT_VERSION_MAJOR}\n#define VERSION_MINOR           ${PROJECT_VERSION_MINOR}\n#define VERSION_PATCH           ${PROJECT_VERSION_PATCH}\n#define VERSION_STRING          \"${PROJECT_VERSION_STRING}\"\n#define GIT_TAG                 \"${GIT_LATEST_TAG}\"\n")

    if(EXISTS ${VERSION_HEADER_PATH})
        file(READ ${VERSION_HEADER_PATH} OLD_HEADER_CONTENT)
    else()
        set(OLD_HEADER_CONTENT "")
    endif()

    if(NOT "${OLD_HEADER_CONTENT}" STREQUAL "${VERSION_HEADER_CONTENT}")
        file(WRITE ${VERSION_HEADER_PATH} "${VERSION_HEADER_CONTENT}")
        message(STATUS "Generated new version header: ${PROJECT_VERSION_STRING}")
    else()
        message(STATUS "Version header is already up-to-date: ${PROJECT_VERSION_STRING}")
    endif()
endif()

project(FluidNC_gCodeSender VERSION ${PROJECT_VERSION_STRING} LANGUAGES CXX)
# --- End Versioning ---

# Set C++ standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_BUILD_TYPE Debug)
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")

# Find wxWidgets - point to our specific build (using working template)
# set(wxWidgets_ROOT_DIR "C:/wxWidgets-3.3.1") # Disabled for generic build
# set(wxWidgets_LIB_DIR "${wxWidgets_ROOT_DIR}/lib/gcc_lib") # Disabled for generic build
# set(wxWidgets_CONFIGURATION mswu) # Disabled for generic build
find_package(wxWidgets REQUIRED COMPONENTS core base adv net aui gl stc)

# Manually set wxWidgets libraries and includes for MinGW static build
# set(wxWidgets_LIBRARIES
#     "${wxWidgets_LIB_DIR}/libwxmsw33u_aui.a"
#     "${wxWidgets_LIB_DIR}/libwxmsw33u_stc.a"
#     "${wxWidgets_LIB_DIR}/libwxscintilla.a"
#     "${wxWidgets_LIB_DIR}/libwxlexilla.a"
#     "${wxWidgets_LIB_DIR}/libwxmsw33u_adv.a"
#     "${wxWidgets_LIB_DIR}/libwxmsw33u_core.a"
#     "${wxWidgets_LIB_DIR}/libwxmsw33u_gl.a"
#     "${wxWidgets_LIB_DIR}/libwxbase33u.a"
#     "${wxWidgets_LIB_DIR}/libwxbase33u_net.a"
#     "${wxWidgets_LIB_DIR}/libwxtiff.a"
#     "${wxWidgets_LIB_DIR}/libwxjpeg.a"
#     "${wxWidgets_LIB_DIR}/libwxpng.a"
#     "${wxWidgets_LIB_DIR}/libwxzlib.a"
#     "${wxWidgets_LIB_DIR}/libwxregexu.a"
#     "${wxWidgets_LIB_DIR}/libwxexpat.a"
#     gdiplus kernel32 user32 gdi32 winspool comdlg32 advapi32 shell32 ole32 oleaut32
#     uuid odbc32 odbccp32 comctl32 rpcrt4 winmm uxtheme shlwapi version msimg32 oleacc wsock32 wininet ws2_32 iphlpapi imm32
# )
# set(wxWidgets_INCLUDE_DIRS
#     "${wxWidgets_ROOT_DIR}/include"
#     "${wxWidgets_ROOT_DIR}/lib/gcc_lib/mswu"
# )
# set(wxWidgets_DEFINITIONS -D__WXMSW__)

# Let find_package handle includes and definitions
include_directories(${wxWidgets_INCLUDE_DIRS})
add_definitions(${wxWidgets_DEFINITIONS})

# Force ASCII-only compilation to ensure cross-platform compatibility
add_definitions(-UUNICODE -U_UNICODE)

# Use single-header nlohmann/json approach
if(EXISTS "${CMAKE_SOURCE_DIR}/../external/json.hpp")
    message(STATUS "Using single-header nlohmann/json")
    add_library(nlohmann_json INTERFACE)
    target_include_directories(nlohmann_json INTERFACE ${CMAKE_SOURCE_DIR}/../external)
    # Create alias for consistency
    add_library(nlohmann_json::nlohmann_json ALIAS nlohmann_json)
else()
    message(STATUS "Looking for system nlohmann/json")
    find_package(nlohmann_json REQUIRED)
endif()

# Threading support
find_package(Threads REQUIRED)

# Platform-specific settings
if(WIN32)
    set(CMAKE_WIN32_EXECUTABLE ON)
endif()

# Get additional Git information for build info display
execute_process(
    COMMAND ${GIT_EXECUTABLE} --git-dir=${CMAKE_SOURCE_DIR}/../.git --work-tree=${CMAKE_SOURCE_DIR}/.. rev-parse --short HEAD
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    OUTPUT_VARIABLE GIT_COMMIT_HASH
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET
)
execute_process(
    COMMAND ${GIT_EXECUTABLE} --git-dir=${CMAKE_SOURCE_DIR}/../.git --work-tree=${CMAKE_SOURCE_DIR}/.. rev-parse --abbrev-ref HEAD
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    OUTPUT_VARIABLE GIT_BRANCH
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET
)
execute_process(
    COMMAND ${GIT_EXECUTABLE} --git-dir=${CMAKE_SOURCE_DIR}/../.git --work-tree=${CMAKE_SOURCE_DIR}/.. describe --tags --dirty --always
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    OUTPUT_VARIABLE GIT_DESCRIBE
    OUTPUT_STRIP_TRAILING_WHITESPACE
    ERROR_QUIET
)



# Generate build timestamp
string(TIMESTAMP BUILD_TIMESTAMP "%Y-%m-%d %H:%M:%S UTC" UTC)

# Get compiler version
if(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    execute_process(
        COMMAND ${CMAKE_CXX_COMPILER} --version
        OUTPUT_VARIABLE COMPILER_VERSION_OUTPUT
        OUTPUT_STRIP_TRAILING_WHITESPACE
        ERROR_QUIET
    )
    # Extract GCC version (first line, get version number)
    string(REGEX MATCH "[0-9]+\\.[0-9]+\\.[0-9]+" COMPILER_VERSION "${COMPILER_VERSION_OUTPUT}")
    if(NOT COMPILER_VERSION)
        set(COMPILER_VERSION "unknown")
    endif()
else()
    set(COMPILER_VERSION "unknown")
endif()

# Get CMake version
set(CMAKE_VERSION_STRING "${CMAKE_VERSION}")

# Get wxWidgets version (from the path we're using)
set(WXWIDGETS_VERSION "3.3.1")

# Get nlohmann/json version (from external/json.hpp if it exists)
set(NLOHMANN_JSON_VERSION "unknown")
if(EXISTS "${CMAKE_SOURCE_DIR}/../external/json.hpp")
    file(READ "${CMAKE_SOURCE_DIR}/../external/json.hpp" JSON_CONTENT)
    if(JSON_CONTENT MATCHES "version ([0-9]+\\.[0-9]+\\.[0-9]+)")
        set(NLOHMANN_JSON_VERSION "${CMAKE_MATCH_1}")
    endif()
endif()

# Get MinGW version info
if(MINGW)
    execute_process(
        COMMAND ${CMAKE_CXX_COMPILER} -dumpmachine
        OUTPUT_VARIABLE MINGW_TARGET
        OUTPUT_STRIP_TRAILING_WHITESPACE
        ERROR_QUIET
    )
    if(NOT MINGW_TARGET)
        set(MINGW_TARGET "unknown")
    endif()
else()
    set(MINGW_TARGET "not-mingw")
endif()

# Create build counter increment script
set(BUILD_COUNTER_SCRIPT "${CMAKE_BINARY_DIR}/increment_build_counter.cmake")
file(WRITE "${BUILD_COUNTER_SCRIPT}"
    "# Increment build counter\n"
    "set(BUILD_COUNTER_FILE \"${CMAKE_BINARY_DIR}/build_counter.txt\")\n"
    "if(EXISTS \"\${BUILD_COUNTER_FILE}\")\n"
    "    file(READ \"\${BUILD_COUNTER_FILE}\" CURRENT_COUNT)\n"
    "    string(STRIP \"\${CURRENT_COUNT}\" CURRENT_COUNT)\n"
    "    if(NOT CURRENT_COUNT MATCHES \"^[0-9]+$\")\n"
    "        set(CURRENT_COUNT 0)\n"
    "    endif()\n"
    "    math(EXPR NEW_COUNT \"\${CURRENT_COUNT} + 1\")\n"
    "else()\n"
    "    set(NEW_COUNT 1)\n"
    "endif()\n"
    "file(WRITE \"\${BUILD_COUNTER_FILE}\" \"\${NEW_COUNT}\")\n"
    "message(STATUS \"Build counter incremented to: \${NEW_COUNT}\")\n"
)

# Source files
set(CORE_SOURCES
    ../src/core/StateManager.cpp
    ../src/core/ErrorHandler.cpp
    ../src/core/UpdateChecker.cpp
    # ../src/core/ConnectionManager.cpp # Temporarily disabled
    ../src/core/CommunicationManager.cpp
    ../src/core/MachineConfigManager.cpp
    ../src/core/HomingManager.cpp
    ../src/core/SimpleLogger.cpp
    ../src/core/Version.cpp
    ../src/core/BuildCounter.cpp
    ../src/core/NetworkScanner.cpp
    ../src/core/NetworkManager.cpp
    ../src/core/NetworkConnection.cpp
    ../src/core/MacVendorLookup.cpp
    ../src/core/FluidNCClient.cpp
    ../src/core/GCodeParser.cpp
    # ../src/core/GCodeGenerator.cpp
    # ../src/core/SVGLoader.cpp
    # ../src/core/MacroEngine.cpp
    # ../src/core/GCodeEditor.cpp
)

set(GUI_SOURCES
    ../src/gui/MainFrame.cpp
    ../src/gui/WelcomeDialog.cpp
    ../src/gui/AboutDialog.cpp
    ../src/gui/ProjectInfoDialog.cpp
    ../src/gui/DROPanel.cpp
    ../src/gui/JogPanel.cpp
    ../src/gui/MachineManagerPanel.cpp
    ../src/gui/MachineVisualizationPanel.cpp
    ../src/gui/AddMachineDialog.cpp
    ../src/gui/NetworkScanDialog.cpp
    ../src/gui/ConsolePanel.cpp
    ../src/gui/MacroConfigDialog.cpp
    ../src/gui/GCodeEditor.cpp
    ../src/gui/MacroPanel.cpp
    ../src/gui/SVGViewer.cpp
    ../src/gui/SettingsPanel.cpp
    ../src/gui/SettingsDialog.cpp
    ../src/gui/TelnetSetupPanel.cpp
    ../src/gui/NotificationSystem.cpp
)

set(APP_SOURCES
    ../src/main.cpp
    ../src/App.cpp
)

# Windows resource file
if(WIN32)
    # set(RESOURCE_FILES ../src/app.rc) # Disabled for non-Windows build
endif()

# Include directories
include_directories(../src)
include_directories(../src/core)
include_directories(../src/gui)

# Create executable
add_executable(${PROJECT_NAME} 
    ${CORE_SOURCES} 
    ${GUI_SOURCES} 
    ${APP_SOURCES}
    ${RESOURCE_FILES}
)


# Add custom command to increment build counter before linking
add_custom_command(TARGET ${PROJECT_NAME}
    PRE_BUILD
    COMMAND ${CMAKE_COMMAND} -P "${BUILD_COUNTER_SCRIPT}"
    COMMENT "Incrementing build counter"
)

# Include the build directory for generated version header
target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_BINARY_DIR})

# Add compile definitions for build information (non-version related)
target_compile_definitions(${PROJECT_NAME} PRIVATE
    GIT_COMMIT_HASH="${GIT_COMMIT_HASH}"
    GIT_BRANCH="${GIT_BRANCH}"
    GIT_DESCRIBE="${GIT_DESCRIBE}"
    BUILD_TIMESTAMP="${BUILD_TIMESTAMP}"
    COMPILER_VERSION="${COMPILER_VERSION}"
    CMAKE_VERSION_STRING="${CMAKE_VERSION_STRING}"
    WXWIDGETS_VERSION="${WXWIDGETS_VERSION}"
    NLOHMANN_JSON_VERSION="${NLOHMANN_JSON_VERSION}"
    MINGW_TARGET="${MINGW_TARGET}"
)

# Link libraries
target_link_libraries(${PROJECT_NAME} 
    ${wxWidgets_LIBRARIES}
    nlohmann_json::nlohmann_json
    Threads::Threads
)

# Windows specific settings (from working template)
if(WIN32)
    set_target_properties(${PROJECT_NAME} PROPERTIES
        WIN32_EXECUTABLE TRUE
    )
    
    # MinGW specific: ensure proper linking
    if(MINGW)
        target_link_libraries(${PROJECT_NAME} -static-libgcc -static-libstdc++)
    endif()
endif()

# Copy resources
file(COPY ../resources DESTINATION ${CMAKE_BINARY_DIR})

# Install target
install(TARGETS ${PROJECT_NAME} DESTINATION bin)
install(DIRECTORY ../resources DESTINATION share/${PROJECT_NAME})
