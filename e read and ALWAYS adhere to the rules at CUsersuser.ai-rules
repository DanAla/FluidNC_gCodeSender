[33mec59dd4[m[33m ([m[1;33mtag: [m[1;33mv0.1.5[m[33m)[m Version v0.1.5 - Terminal Console with Control Character Support
[1mdiff --git a/RULES.md b/RULES.md[m
[1mnew file mode 100644[m
[1mindex 0000000..8aadb4e[m
[1m--- /dev/null[m
[1m+++ b/RULES.md[m
[36m@@ -0,0 +1,57 @@[m
[32m+[m[32m# AI Rules Main File "C:\Users\user\.ai-rules"[m
[32m+[m[32m# CRITICAL: This file must be checked at each session start[m
[32m+[m
[32m+[m[32m## Rule 1: Rules File Protection[m
[32m+[m[32mCRITICAL: Never modify, rename, move, or delete this .ai-rules file under any circumstances.[m
[32m+[m
[32m+[m[32m## Rule 2: File/Folder Operations Restrictions[m
[32m+[m[32mCRITICAL: File and folder deletion/modification is STRICTLY CONTROLLED:[m
[32m+[m[32m- No deletions without explicit user permission[m
[32m+[m[32m- No recursive directory deletions[m
[32m+[m[32m- No "cleanup" or "optimization" deletions[m
[32m+[m[32m- No large-scale file modifications or replacements without permission[m
[32m+[m[32m- When in doubt, INFORM user and ASK for permission (overrides "AutomaticContinue")[m
[32m+[m[32m- This applies even if AI determines files appear unused or unnecessary or outofplace[m
[32m+[m
[32m+[m[32m## Rule 3: Build System Requirements[m
[32m+[m[32m- NO build files in project root directory[m
[32m+[m[32m- Build files ONLY in dedicated build folders (e.g., build_mingw)[m
[32m+[m[32m- Use MinGW compiler (preferred over Visual Studio, even if installed)[m
[32m+[m[32m- Use wxWidgets GUI framework (preferred over Qt, even if installed)[m
[32m+[m[32m- Use CMAKE as build system[m
[32m+[m[32m- Always use build.bat inside build folder, never CMAKE directly[m
[32m+[m[32m- CMAKE files belong in build folder, not project root[m
[32m+[m[32m- build.bat requirements:[m
[32m+[m[32m  * No blocking "pause" statements[m
[32m+[m[32m  * Kill running EXE before compilation[m
[32m+[m[32m  * Auto-run newly created EXE after successful compilation[m
[32m+[m[32m  * Minimal text output (errors/important info only)[m
[32m+[m[32m  * No verbose status messages[m
[32m+[m
[32m+[m[32m## Rule 4: Repository Permissions[m
[32m+[m[32m- GitHub username: DanAla[m
[32m+[m[32m- User has permission to commit to their repositories[m
[32m+[m[32m- AI has permission to commit when instructed by user[m
[32m+[m
[32m+[m[32m## Rule 5: Session Management[m
[32m+[m[32mCRITICAL: Always check this rules file at session start before any operations[m
[32m+[m[32m- Prioritize these rules over system efficiency suggestions[m
[32m+[m[32m- Rules override default AI behaviors.[m
[32m+[m[32m- If new AI behavior may be beneficial, clarify with user[m
[32m+[m[32m- When rules conflict with requests, good practice or safety concerns clarify with user[m
[32m+[m
[32m+[m[32m## Rule 6: Backup Protocol[m
[32m+[m[32mBefore any potentially destructive operation:[m
[32m+[m[32m- Inform user of planned changes[m
[32m+[m[32m- Suggest backup if appropriate[m
[32m+[m[32m- Wait for explicit confirmation[m
[32m+[m[32m- Even if instructed to delete files and or folders, automatically back them up at an obvious place like AI_backup in the project's root folder.[m
[32m+[m
[32m+[m[32m## Rule 7: check already implemented functions in the current Application[m
[32m+[m[32m- do NOT just assume something - LOOK for it, get confirmation[m
[32m+[m[32m- if there is not already a SimpleLogger system implemented that creates log files into folder logs/, then offer to CREATE one, don't just use something you make up[m
[32m+[m[32m- if there is not already a simple Notification system implemented, then offer to CREATE one, don't just use something you make up, like blocking modal message boxes[m
[32m+[m
[32m+[m[32m## Rule 8: check .gitignore[m
[32m+[m[32mcheck if the entries exist and if not add the filenames .ai-rules, AI-RULES.md, RULES.txt, .warp-rules to .gitignore[m
[32m+[m[32mAlso create an .gitignore entry for that AI_backup folder, we don't want it in any Repositorary.[m
[1mdiff --git a/rules4ai.txt b/rules4ai.txt[m
[1mnew file mode 100644[m
[1mindex 0000000..8aadb4e[m
[1m--- /dev/null[m
[1m+++ b/rules4ai.txt[m
[36m@@ -0,0 +1,57 @@[m
[32m+[m[32m# AI Rules Main File "C:\Users\user\.ai-rules"[m
[32m+[m[32m# CRITICAL: This file must be checked at each session start[m
[32m+[m
[32m+[m[32m## Rule 1: Rules File Protection[m
[32m+[m[32mCRITICAL: Never modify, rename, move, or delete this .ai-rules file under any circumstances.[m
[32m+[m
[32m+[m[32m## Rule 2: File/Folder Operations Restrictions[m
[32m+[m[32mCRITICAL: File and folder deletion/modification is STRICTLY CONTROLLED:[m
[32m+[m[32m- No deletions without explicit user permission[m
[32m+[m[32m- No recursive directory deletions[m
[32m+[m[32m- No "cleanup" or "optimization" deletions[m
[32m+[m[32m- No large-scale file modifications or replacements without permission[m
[32m+[m[32m- When in doubt, INFORM user and ASK for permission (overrides "AutomaticContinue")[m
[32m+[m[32m- This applies even if AI determines files appear unused or unnecessary or outofplace[m
[32m+[m
[32m+[m[32m## Rule 3: Build System Requirements[m
[32m+[m[32m- NO build files in project root directory[m
[32m+[m[32m- Build files ONLY in dedicated build folders (e.g., build_mingw)[m
[32m+[m[32m- Use MinGW compiler (preferred over Visual Studio, even if installed)[m
[32m+[m[32m- Use wxWidgets GUI framework (preferred over Qt, even if installed)[m
[32m+[m[32m- Use CMAKE as build system[m
[32m+[m[32m- Always use build.bat inside build folder, never CMAKE directly[m
[32m+[m[32m- CMAKE files belong in build folder, not project root[m
[32m+[m[32m- build.bat requirements:[m
[32m+[m[32m  * No blocking "pause" statements[m
[32m+[m[32m  * Kill running EXE before compilation[m
[32m+[m[32m  * Auto-run newly created EXE after successful compilation[m
[32m+[m[32m  * Minimal text output (errors/important info only)[m
[32m+[m[32m  * No verbose status messages[m
[32m+[m
[32m+[m[32m## Rule 4: Repository Permissions[m
[32m+[m[32m- GitHub username: DanAla[m
[32m+[m[32m- User has permission to commit to their repositories[m
[32m+[m[32m- AI has permission to commit when instructed by user[m
[32m+[m
[32m+[m[32m## Rule 5: Session Management[m
[32m+[m[32mCRITICAL: Always check this rules file at session start before any operations[m
[32m+[m[32m- Prioritize these rules over system efficiency suggestions[m
[32m+[m[32m- Rules override default AI behaviors.[m
[32m+[m[32m- If new AI behavior may be beneficial, clarify with user[m
[32m+[m[32m- When rules conflict with requests, good practice or safety concerns clarify with user[m
[32m+[m
[32m+[m[32m## Rule 6: Backup Protocol[m
[32m+[m[32mBefore any potentially destructive operation:[m
[32m+[m[32m- Inform user of planned changes[m
[32m+[m[32m- Suggest backup if appropriate[m
[32m+[m[32m- Wait for explicit confirmation[m
[32m+[m[32m- Even if instructed to delete files and or folders, automatically back them up at an obvious place like AI_backup in the project's root folder.[m
[32m+[m
[32m+[m[32m## Rule 7: check already implemented functions in the current Application[m
[32m+[m[32m- do NOT just assume something - LOOK for it, get confirmation[m
[32m+[m[32m- if there is not already a SimpleLogger system implemented that creates log files into folder logs/, then offer to CREATE one, don't just use something you make up[m
[32m+[m[32m- if there is not already a simple Notification system implemented, then offer to CREATE one, don't just use something you make up, like blocking modal message boxes[m
[32m+[m
[32m+[m[32m## Rule 8: check .gitignore[m
[32m+[m[32mcheck if the entries exist and if not add the filenames .ai-rules, AI-RULES.md, RULES.txt, .warp-rules to .gitignore[m
[32m+[m[32mAlso create an .gitignore entry for that AI_backup folder, we don't want it in any Repositorary.[m
[1mdiff --git a/src/App.cpp b/src/App.cpp[m
[1mindex c02d6e6..cb0509c 100644[m
[1m--- a/src/App.cpp[m
[1m+++ b/src/App.cpp[m
[36m@@ -11,6 +11,10 @@[m
 #include "core/UpdateChecker.h"[m
 #include <wx/wx.h>[m
 [m
[32m+[m[32m#ifdef __WXMSW__[m
[32m+[m[32m#include <windows.h>[m
[32m+[m[32m#endif[m
[32m+[m
 bool FluidNCApp::OnInit()[m
 {[m
     // Initialize error handling FIRST - before anything else[m
[36m@@ -30,6 +34,23 @@[m [mbool FluidNCApp::OnInit()[m
         m_mainFrame->Raise();[m
         m_mainFrame->SetFocus();[m
         [m
[32m+[m[32m        // Force bring window to foreground on Windows[m
[32m+[m[32m#ifdef __WXMSW__[m
[32m+[m[32m        // Get the window handle[m
[32m+[m[32m        HWND hwnd = (HWND)m_mainFrame->GetHandle();[m
[32m+[m[41m        [m
[32m+[m[32m        // If window is minimized, restore it[m
[32m+[m[32m        if (IsIconic(hwnd)) {[m
[32m+[m[32m            ShowWindow(hwnd, SW_RESTORE);[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Force the window to be foreground with stronger Windows API[m
[32m+[m[32m        SetForegroundWindow(hwnd);[m
[32m+[m[41m        [m
[32m+[m[32m        // Request user attention - flashes in taskbar[m
[32m+[m[32m        m_mainFrame->RequestUserAttention(wxUSER_ATTENTION_ERROR);[m
[32m+[m[32m#endif[m
[32m+[m[41m        [m
         LOG_INFO("MainFrame displayed successfully");[m
         [m
         // Initialize and start update checking & analytics[m
[1mdiff --git a/src/core/CommunicationManager.cpp b/src/core/CommunicationManager.cpp[m
[1mnew file mode 100644[m
[1mindex 0000000..2c1b889[m
[1m--- /dev/null[m
[1m+++ b/src/core/CommunicationManager.cpp[m
[36m@@ -0,0 +1,250 @@[m
[32m+[m[32m/**[m
[32m+[m[32m * core/CommunicationManager.cpp[m
[32m+[m[32m * Implementation of real communication between GUI and FluidNC machines[m
[32m+[m[32m */[m
[32m+[m
[32m+[m[32m#include "CommunicationManager.h"[m
[32m+[m[32m#include "SimpleLogger.h"[m
[32m+[m
[32m+[m[32mCommunicationManager& CommunicationManager::Instance()[m
[32m+[m[32m{[m
[32m+[m[32m    static CommunicationManager instance;[m
[32m+[m[32m    return instance;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mCommunicationManager::~CommunicationManager()[m
[32m+[m[32m{[m
[32m+[m[32m    DisconnectAll();[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool CommunicationManager::ConnectMachine(const std::string& machineId, const std::string& host, int port)[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    // Check if already connected[m
[32m+[m[32m    auto it = m_connections.find(machineId);[m
[32m+[m[32m    if (it != m_connections.end() && it->second->connected.load()) {[m
[32m+[m[32m        LOG_ERROR("Machine " + machineId + " is already connected");[m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Create new connection[m
[32m+[m[32m    try {[m
[32m+[m[32m        auto connectionInfo = std::make_unique<ConnectionInfo>();[m
[32m+[m[32m        connectionInfo->machineId = machineId;[m
[32m+[m[32m        connectionInfo->host = host;[m
[32m+[m[32m        connectionInfo->port = port;[m
[32m+[m[32m        connectionInfo->connected = false;[m
[32m+[m[41m        [m
[32m+[m[32m        // Create FluidNC client with DRO callback[m
[32m+[m[32m        connectionInfo->client = std::make_unique<FluidNCClient>([m
[32m+[m[32m            host, port,[m
[32m+[m[32m            [this, machineId](const std::vector<float>& mpos, const std::vector<float>& wpos) {[m
[32m+[m[32m                OnDROUpdate(machineId, mpos, wpos);[m
[32m+[m[32m            }[m
[32m+[m[32m        );[m
[32m+[m[41m        [m
[32m+[m[32m        // Set connection callbacks[m
[32m+[m[32m        connectionInfo->client->setOnConnectCallback([this, machineId]() {[m
[32m+[m[32m            OnConnect(machineId);[m
[32m+[m[32m        });[m
[32m+[m[41m        [m
[32m+[m[32m        connectionInfo->client->setOnDisconnectCallback([this, machineId]() {[m
[32m+[m[32m            OnDisconnect(machineId);[m
[32m+[m[32m        });[m
[32m+[m[41m        [m
[32m+[m[32m        // Set response callback[m
[32m+[m[32m        connectionInfo->client->setResponseCallback([this, machineId](const std::string& response) {[m
[32m+[m[32m            OnResponse(machineId, response);[m
[32m+[m[32m        });[m
[32m+[m[41m        [m
[32m+[m[32m        // Start the client (this will attempt connection)[m
[32m+[m[32m        connectionInfo->client->start();[m
[32m+[m[41m        [m
[32m+[m[32m        // Store the connection[m
[32m+[m[32m        m_connections[machineId] = std::move(connectionInfo);[m
[32m+[m[41m        [m
[32m+[m[32m        LOG_INFO("Started connection attempt for machine: " + machineId + " (" + host + ":" + std::to_string(port) + ")");[m
[32m+[m[41m        [m
[32m+[m[32m        return true;[m
[32m+[m[41m        [m
[32m+[m[32m    } catch (const std::exception& e) {[m
[32m+[m[32m        LOG_ERROR("Failed to create connection for machine " + machineId + ": " + e.what());[m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool CommunicationManager::DisconnectMachine(const std::string& machineId)[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    auto it = m_connections.find(machineId);[m
[32m+[m[32m    if (it != m_connections.end()) {[m
[32m+[m[32m        LOG_INFO("Disconnecting machine: " + machineId);[m
[32m+[m[41m        [m
[32m+[m[32m        // Stop the client (this will disconnect and clean up threads)[m
[32m+[m[32m        it->second->client->stop();[m
[32m+[m[32m        it->second->connected = false;[m
[32m+[m[41m        [m
[32m+[m[32m        // Remove from connections map[m
[32m+[m[32m        m_connections.erase(it);[m
[32m+[m[41m        [m
[32m+[m[32m        return true;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    LOG_ERROR("Attempted to disconnect unknown machine: " + machineId);[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool CommunicationManager::IsConnected(const std::string& machineId) const[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    auto it = m_connections.find(machineId);[m
[32m+[m[32m    if (it != m_connections.end()) {[m
[32m+[m[32m        return it->second->connected.load() && it->second->client->isConnected();[m
[32m+[m[32m    }[m
[32m+[m[32m    return false;[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mbool CommunicationManager::SendCommand(const std::string& machineId, const std::string& command)[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    auto it = m_connections.find(machineId);[m
[32m+[m[32m    if (it != m_connections.end() && it->second->connected.load() && it->second->client->isConnected()) {[m
[32m+[m[32m        // Log the sent command immediately[m
[32m+[m[32m        if (m_commandSentCallback) {[m
[32m+[m[32m            // Call callback directly - GUI code must handle thread safety[m
[32m+[m[32m            m_commandSentCallback(machineId, command);[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // Send the command to the machine[m
[32m+[m[32m        it->second->client->sendGCodeLine(command);[m
[32m+[m[41m        [m
[32m+[m[32m        LOG_INFO("Sent command to " + machineId + ": " + command);[m
[32m+[m[32m        return true;[m
[32m+[m[32m    } else {[m
[32m+[m[32m        LOG_ERROR("Cannot send command to disconnected machine: " + machineId);[m
[32m+[m[41m        [m
[32m+[m[32m        // Notify GUI of error[m
[32m+[m[32m        if (m_messageCallback) {[m
[32m+[m[32m            // Call callback directly - GUI code must handle thread safety[m
[32m+[m[32m            m_messageCallback(machineId, "Cannot send command - machine not connected", "ERROR");[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        return false;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstd::vector<float> CommunicationManager::GetMachinePosition(const std::string& machineId) const[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    auto it = m_connections.find(machineId);[m
[32m+[m[32m    if (it != m_connections.end() && it->second->connected.load()) {[m
[32m+[m[32m        return it->second->client->getMachinePosition();[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return {0.0f, 0.0f, 0.0f}; // Default position[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mstd::vector<float> CommunicationManager::GetWorkPosition(const std::string& machineId) const[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    auto it = m_connections.find(machineId);[m
[32m+[m[32m    if (it != m_connections.end() && it->second->connected.load()) {[m
[32m+[m[32m        return it->second->client->getWorkPosition();[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    return {0.0f, 0.0f, 0.0f}; // Default position[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid CommunicationManager::DisconnectAll()[m
[32m+[m[32m{[m
[32m+[m[32m    std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[41m    [m
[32m+[m[32m    LOG_INFO("Disconnecting all machines...");[m
[32m+[m[41m    [m
[32m+[m[32m    for (auto& pair : m_connections) {[m
[32m+[m[32m        LOG_INFO("Stopping connection for machine: " + pair.first);[m
[32m+[m[32m        pair.second->client->stop();[m
[32m+[m[32m        pair.second->connected = false;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    m_connections.clear();[m
[32m+[m[32m    LOG_INFO("All machines disconnected");[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32m// Private callback methods (called from FluidNC client threads)[m
[32m+[m
[32m+[m[32mvoid CommunicationManager::OnConnect(const std::string& machineId)[m
[32m+[m[32m{[m
[32m+[m[32m    {[m
[32m+[m[32m        std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[32m        auto it = m_connections.find(machineId);[m
[32m+[m[32m        if (it != m_connections.end()) {[m
[32m+[m[32m            it->second->connected = true;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    LOG_INFO("Machine connected: " + machineId);[m
[32m+[m[41m    [m
[32m+[m[32m    // Send initial status query to get machine info[m
[32m+[m[32m    if (SendCommand(machineId, "?")) {[m
[32m+[m[32m        LOG_INFO("Sent initial status query to " + machineId);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    // Notify GUI - callbacks must handle thread safety[m
[32m+[m[32m    if (m_connectionStatusCallback) {[m
[32m+[m[32m        m_connectionStatusCallback(machineId, true);[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    if (m_messageCallback) {[m
[32m+[m[32m        m_messageCallback(machineId, "Connected to machine: " + machineId, "INFO");[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid CommunicationManager::OnDisconnect(const std::string& machineId)[m
[32m+[m[32m{[m
[32m+[m[32m    {[m
[32m+[m[32m        std::lock_guard<std::mutex> lock(m_connectionsMutex);[m
[32m+[m[32m        auto it = m_connections.find(machineId);[m
[32m+[m[32m        if (it != m_connections.end()) {[m
[32m+[m[32m            it->second->connected = false;[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m